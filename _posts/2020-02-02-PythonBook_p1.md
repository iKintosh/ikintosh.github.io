# Читаю “Python. К вершинам мастерства”. Часть 1

## Глава 1. Про данные в Питоне
В питоне есть очень удобные магические методы, которые позволяют реализовать классы, 
которые ведут себя также как и дефолтные (утиная типизация). 
Это позволяет экономить время и силы на разработку: `repl`, `len`, `add`, `mul`, `getitem`, etc. 
(Лучше ещё раз пересмотреть пример, тк он действительно очень изящный)

TDD можно использовать только в том случае, если ты точно знаешь, какое именно поведение функции или класса ты хочешь получить 
(пример про класс вектор)

## Глава 2. Про листы и кортежи _(где тут ставить ударение?)_

List compression следует использовать, когда нужно получить новый лист. 
Причем в эту конструкцию можно добавлять условия, или создавать лист из объектов, или интегрироваться по вложенным спискам. 
Аналогично можно создать генераторы, только в круглых скобках.

Интересная структура данных NamedTuple в питоне. Надо обязательно воспользоваться. Tuple также можно использовать 
для передачи неименованных аргументов (через *args). Также в очередной раз повторил про ссылки в list.  
Выяснил, что числа хранить лучше в array.array (тк они занимают значительно меньше места), а если у меня очередь, 
то есть тип deque, который работает быстрее при добавлении/удалении элементов по краям очереди. 

Еще для работы с сортированными массивами (листами) стоит использовать библиотеку bisect — она реализует бинарный поиск и 
бинарный поиск со вставкой нового элемента. А ... это очень удобная штука, которая позволяет писать так 
a[i, ... ] == a[i, :, :, ;] (в данном случае а предполагается четырехмерным массивом numpy). 
К сожалению, с листами в Python такое не работает.

## Глава 3. Про словари и множества
Словари — очень классная структура данных. Они очень хорошо оптимизированы, и даже используются внутри внутренностей питона. 
Аналогично спискам, можно делать dict compression. Также есть методы чтобы получать доступ к несуществующему ключу и не получать ошибку.

Например `d.get(key, [default])` возвращает или `value` или присваивает `default`. Но также есть ещё `setdefault`, который 
одновременно может обновлять `value` (то есть если нужно изменять значение по ключу, то такой метод позволяет за один поиск ключа 
или обновить значение или присвоить, если не существует). Очень похожим образом работает defaultdict — структура данных в модуле 
`collections` (очень полезный модуль, оказывается).

Если хочется создать свой кастомный словарь (ну мало ли), то лучше наследоваться от `UserDict`, а не от `dict`. 

Также есть очень интересная идея, как mapping proxy type, который создаёт отображение изменяемого объекта, но только с возможностью чтения. (Не знаю зачем это может быть нужно, но выглядит очень эффектно)
Словари и множества работают очень быстро благодаря тому, что используются хэштаблицы. 
Это занимает много памяти, но скорость поиска вхождения ключа в таблицу значительно быстрее, чем поиск значения в листе. 
Во множествах реализован математический синтаксис для поиска пересечения, объединения, разницы и тд. 
Это может быть очень удобно и выразительно.
## Глава 4. Про кодировки
Не очень интересная и понятная для меня часть: кодировки. 
Лучше всего кодировку указывать явно при открытии и закрытии файла, 
а внутри бизнес логики приложения работать с только со строками.
