# Читаю "Использование Docker". Часть 5

## Prev
[Часть 1](https://ikintosh.github.io/2020/03/19/docker.html)

[Часть 2](https://ikintosh.github.io/2020/04/03/docker_2.html)

[Часть 3](https://ikintosh.github.io/2020/04/11/docker_3.html)

[Часть 4](https://ikintosh.github.io/2020/05/02/docker_4.html)

Это будет последняя часть моих мини-саммари о докере. Это связано с тем, что я тупой и не понял главы 9-11. Поэтому дам только их краткий обзор.

## Глава 9

Тут описывается, как развернуть контейнеры на своих машинах. Как использовать Ansible для настройки хостов и тд. Как разворачивать контейнеры в облаке. И как управлять запуском и перезапуском контейнеров.

Вся глава состоит из кучи различных конфиг-файлов и их описания. Это очень полезно, если бы я был знаком хотя бы с парой инструментов в этой главе. 

## Глава 10.

Тоже состоит из кода, но на этот раз предлагается настраивать логгирование того, что происходит с контейнерами. Есть описание стека ELK -- о нем даже я знаю. Но эту главу стоит читать, когда уже озаботился логгированием и контролем за хостами.

## Глава 11.

Эта глава максимально близко подходит к тому, зачем вообще нужна оркестрация. Здесь пробуем поднять приложение в контейнерах на двух хостах и заставить всю эту конструкцию работать друг с другом.

Предполагается, что на одном хосте работает само приложение, а на втором лежит БД. Они должны знать друг о друге и соединяться через сеть. С одной стороны можно указывать все IP и порты руками, но тогда это не отвечает идеологии докера: разработка, тестирование и деплой одним и тем же кодом. Значит нужно что-то сделать с окружением.

### Идея 1

Поднять специальный контейнер, в котором и будет все маппится. Удобно, что все это работает внутри докера и никаких дополнительных утилит. Сложности возникают тогда, когда логика для маппинга становится очень большой или сложной.

### Идея 2

Воспользоваться специальными инструментами. Например, etcd и SkyDNS. Их нужно будет поставить на каждый хост и настроить. Процесс настройки описан в книге. Настройка одинакова для больших маппингов.

### Идея 3

Ставить комплексные сетевые решения. Они приведены в книге.

Проблема всех этих идей: чтобы поднять приложение на двух хостах нужно совершить огромное количество работы. При этом они только обеспечивают сетевую среду для работы контейнеров и помогают контейнерам обнаружить друг друга. 

## Глава 12.

И тут на помощь приходит Kubernetes. Он использует инструменты из предыдущей главы и берет настройку сетевых соединений на себя. А еще он берет на себя вопрос запуска контейнеров и обеспечения стабильности работы приложения.

Kubernetes предлагает свои абстракции для этого. Окружения > приложения > сервисы > поды. Под -- это экземпляр докер образа. Поды постоянно умирают и рождаются. Взаимодействие происходит на уровне сервиса. Сервис -- абстракция над подами, которая балансирует нагрузку и предоставляет интерфейсы другим сервисам. Фактически то, что раньше было контейнером в докере, в кубернетисе делится на две части. Сам исполняющий код лежит в подах, а за соединение с другими компонентами приложения отвечает сервис.

Это самые-самые основы кубернетиса. О нем я наверняка буду писать более подробно в будущем.

Также в главе шла речь о других системах оркестрации и управления контейнерами: Swarm, Mesos и Rancher. Не буду писать о них более подробно, тк сейчас Kubernetes является де-факто стандартом для такого рода задач.

## Итог.

Книга настолько хорошая, что я понял около половины прочитанного. Имеет смысл через полгода-год её еще раз посмотреть. Я начинал читать эту книгу с прикладной целью: уметь упаковывать мои ML-модели в докер-образы и потом запускать их. Считаю, что эта цель была достигнута. 

PS. Сейчас мне не понадобились или показались сложными и непонятными главы 7, 9, 10, 11 и 13 (Распространение образов, Развертывание, Журналы событий и контроль, Сетевая среда, Безопасность). 
